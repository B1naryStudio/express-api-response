{
  "name": "should",
  "description": "test framework agnostic BDD-style assertions",
  "version": "4.1.0",
  "author": {
    "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/shouldjs/should.js.git"
  },
  "homepage": "https://github.com/shouldjs/should.js",
  "scripts": {
    "test": "gulp test",
    "zuul": "zuul -- ./test/**/*.test.js ./test/*.test.js",
    "browser": "gulp script"
  },
  "devDependencies": {
    "browserify": "latest",
    "mocha-better-spec-reporter": "1.1.0",
    "gulp-mocha": "1.1.1",
    "gulp-uglify": "1.0.1",
    "gulp-util": "^2.2.14",
    "gulp": "^3.6.2",
    "vinyl-source-stream2": "^0.1.1",
    "gulp-load-plugins": "^0.5.1",
    "gulp-rename": "^1.2.0",
    "gulp-header": "^1.0.2",
    "mocha": "latest",
    "zuul": "latest"
  },
  "keywords": [
    "test",
    "bdd",
    "assert"
  ],
  "main": "./lib/should.js",
  "license": "MIT",
  "dependencies": {
    "should-equal": "0.0.1"
  },
  "readme": "# should.js\r\n\r\n[![Build Status](https://travis-ci.org/shouldjs/should.js.svg?branch=master)](https://travis-ci.org/shouldjs/should.js)\r\n\r\n[![Selenium Test Status](https://saucelabs.com/browser-matrix/shouldjs.svg)](https://saucelabs.com/u/shouldjs)\r\n\r\n_should_ is an expressive, readable, framework-agnostic assertion library. The main goals of this library are __to be expressive__ and __to be helpful__. It keeps your test code clean, and your error messages helpful.\r\n\r\n_should_ extends the `Object.prototype` with a single non-enumerable getter that allows you to express how that object should behave. It also returns itself when required with `require`.\r\n\r\n### Breaking changes for 4.x\r\n\r\nPlease check [wiki](https://github.com/shouldjs/should.js/wiki/Breaking-changes-4.x).\r\n\r\n## Example\r\n```javascript\r\nvar should = require('should');\r\n\r\nvar user = {\r\n    name: 'tj'\r\n  , pets: ['tobi', 'loki', 'jane', 'bandit']\r\n};\r\n\r\nuser.should.have.property('name', 'tj');\r\nuser.should.have.property('pets').with.lengthOf(4);\r\n\r\n// If the object was created with Object.create(null)\r\n// then it doesn't inherit `Object.prototype`, so it will not have `.should` getter\r\n// so you can do:\r\nshould(user).have.property('name', 'tj');\r\n\r\n// also you can test in that way for null's\r\nshould(null).not.be.ok;\r\n\r\nsomeAsyncTask(foo, function(err, result){\r\n  should.not.exist(err);\r\n  should.exist(result);\r\n  result.bar.should.equal(foo);\r\n});\r\n```\r\n## To begin\r\n\r\n 1. Install it:\r\n\r\n    ```bash\r\n    $ npm install should --save-dev\r\n    ```\r\n\r\n 2. Require it and use:\r\n\r\n    ```js\r\n    var should = require('should');\r\n\r\n    (5).should.be.exactly(5).and.be.a.Number;\r\n    ```\r\n\r\n## In browser\r\n\r\nWell, even when browsers by complains of authors has 100% es5 support, it does not mean it has not bugs. Please see [wiki](https://github.com/shouldjs/should.js/wiki/Known-Bugs) for known bugs.\r\n\r\nIf you want to use _should_ in browser, use the `should.js` file in the root of this repository, or build it yourself. To build a fresh version:\r\n\r\n```bash\r\n$ npm install\r\n$ gulp script\r\n```\r\n\r\nThe script is exported to `window.Should`. It is the same as using `should` statically:\r\n\r\n```js\r\nShould(5).be.exactly(5)\r\n```\r\n\r\nAlso, in the case of node.js, `Object.prototype` is extended with `should` (hence the capital S in `window.Should`):\r\n\r\n```js\r\nwindow.should.be.exactly(window);\r\n// the same\r\n// window is host object\r\nshould.be.exactly(window);\r\n// you should not really care about it\r\n\r\n(5).should.be.exactly(5);\r\n```\r\nYou can easy install it with npm or bower:\r\n```\r\nnpm install should --save-dev\r\n# or\r\nbower install shouldjs/should.js\r\n```\r\n\r\n## Static should and assert module\r\n\r\nFor some rare cases _should_ can be used statically, without `Object.prototype`.\r\nIt can be a replacement for the node assert module:\r\n\r\n```javascript\r\nassert.fail(actual, expected, message, operator) // just write wrong should assertion\r\nassert(value, message), assert.ok(value, [message]) // should(value).ok\r\nassert.equal(actual, expected, [message]) // should(actual).eql(expected, [message])\r\nassert.notEqual(actual, expected, [message]) // should(actual).not.eql(expected, [message])\r\nassert.deepEqual(actual, expected, [message]) // should(actual).eql(expected, [message])\r\nassert.notDeepEqual(actual, expected, [message]) // should(actual).not.eql(expected, [message])\r\nassert.strictEqual(actual, expected, [message]) // should(actual).equal(expected, [message])\r\nassert.notStrictEqual(actual, expected, [message]) // should(actual).not.equal(expected, [message])\r\nassert.throws(block, [error], [message]) // should(block).throw([error])\r\nassert.doesNotThrow(block, [message]) // should(block).not.throw([error])\r\nassert.ifError(value) // should(value).Error (to check if it is error) or should(value).not.ok (to check that it is falsy)\r\n```\r\n\r\n## .not\r\n\r\n`.not` negates the current assertion.\r\n\r\n## .any\r\n\r\n`.any` allow for assertions with multiple parameters to assert any of the parameters (but not all). This is similar to the native JavaScript [array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).\r\n\r\n# Assertions\r\n## chaining assertions\r\n\r\nEvery assertion will return a `should.js`-wrapped Object, so assertions can be chained.\r\nTo help chained assertions read more clearly, you can use the following helpers anywhere in your chain: `.an`, `.of`, `.a`, `.and`, `.be`, `.have`, `.with`, `.is`, `.which`. Use them for better readability; they do nothing at all.\r\nFor example:\r\n```js\r\nuser.should.be.an.instanceOf(Object).and.have.property('name', 'tj');\r\nuser.pets.should.be.instanceof(Array).and.have.lengthOf(4);\r\n```\r\nAlmost all assertions return the same object - so you can easy chain them. But some (eg: `.length` and `.property`) move the assertion object to a property value, so be careful.\r\n\r\n## .ok\r\n\r\nAssert that a chained object is truthy in javascript (ie: not '', null, undefined, 0 , NaN).\r\n\r\nAssert truthfulness:\r\n\r\n```javascript\r\ntrue.should.be.ok;\r\n'yay'.should.be.ok;\r\n(1).should.be.ok;\r\n({}).should.be.ok;\r\n```\r\n\r\nor negated:\r\n\r\n```javascript\r\nfalse.should.not.be.ok;\r\n''.should.not.be.ok;\r\n(0).should.not.be.ok;\r\n```\r\n\r\n*Warning:* No assertions can be performed on null and undefined values.\r\ne.g.\r\n```js\r\n  undefined.should.not.be.ok;\r\n```\r\nwill give you `Uncaught TypeError: Cannot read property 'should' of undefined)`.\r\n\r\nIn order to test for null use\r\n```js\r\n(err === null).should.be.true;\r\n```\r\n\r\n## .true\r\n\r\nAssert if a chained object === true:\r\n\r\n```javascript\r\ntrue.should.be.true;\r\n'1'.should.not.be.true;\r\n```\r\n\r\n## .false\r\n\r\nAssert if a chained object === false:\r\n\r\n```javascript\r\nfalse.should.be.false;\r\n(0).should.not.be.false;\r\n```\r\n\r\n## .eql(otherValue)\r\n\r\nAsserts if a chained object is *equal* to otherValue. The object is compared by its actual content, not just reference equality.\r\n\r\n```javascript\r\n({ foo: 'bar' }).should.eql({ foo: 'bar' });\r\n[1,2,3].should.eql([1,2,3]);\r\n// see next example it is correct, even if it is different types, but actual content the same\r\n[1, 2, 3].should.eql({ '0': 1, '1': 2, '2': 3 });\r\n```\r\n## .equal(otherValue) and .exactly(otherValue)\r\n\r\nAsserts if a chained object is strictly equal to `otherValue` (using `===`). It means primitive values compared as is (there is no any type conversion) and reference values compared by references.\r\n\r\n```javascript\r\n(4).should.equal(4);\r\n'test'.should.equal('test');\r\n[1,2,3].should.not.equal([1,2,3]);\r\n(4).should.be.exactly(4);\r\n```\r\n\r\n## .startWith(str)\r\n\r\nAssert that a string starts with `str`.\r\n\r\n```javascript\r\n'foobar'.should.startWith('foo');\r\n'foobar'.should.not.startWith('bar');\r\n```\r\n## .endWith(str)\r\n\r\nAssert that a string ends with `str`.\r\n\r\n```javascript\r\n'foobar'.should.endWith('bar');\r\n'foobar'.should.not.endWith('foo');\r\n```\r\n\r\n## .within(from, to)\r\n\r\nAssert inclusive numeric range (`<= to` and `>= from`):\r\n```javascript\r\nuser.age.should.be.within(5, 50);\r\n(5).should.be.within(5, 10).and.within(5, 5);\r\n```\r\n\r\n## .approximately(num, delta)\r\n\r\nAssert a floating point number is near `num` within the `delta` margin:\r\n\r\n```javascript\r\n(99.99).should.be.approximately(100, 0.1);\r\n```\r\n\r\n## .above(num) and .greaterThan(num)\r\n\r\nAssert a numeric value is above the given value (`> num`):\r\n\r\n```javascript\r\nuser.age.should.be.above(5);\r\nuser.age.should.not.be.above(100);\r\n(5).should.be.above(0);\r\n(5).should.not.be.above(5);\r\n```\r\n\r\n## .below(num) and .lessThan(num)\r\n\r\nAssert a numeric value is below the given value (`< num`):\r\n\r\n```javascript\r\nuser.age.should.be.below(100);\r\nuser.age.should.not.be.below(5);\r\n(5).should.be.below(6);\r\n(5).should.not.be.below(5);\r\n```\r\n\r\n## .NaN\r\n\r\nAssert a numeric value is NaN:\r\n\r\n```javascript\r\n(undefined + 0).should.be.NaN;\r\n```\r\n\r\n## .Infinity\r\n\r\nAssert a numeric value is Infinity:\r\n\r\n```javascript\r\n(1/0).should.be.Infinity;\r\n```\r\n\r\n## .type(str)\r\n\r\nAssert a given object is of a particular type (using __typeof__ operator):\r\n```javascript\r\nuser.should.be.type('object');\r\n'test'.should.be.type('string');\r\n```\r\n\r\n## .instanceof(constructor) and .instanceOf(constructor)\r\n\r\nAssert a given object is an instance of `constructor` (using __instanceof__ operator):\r\n\r\n```javascript\r\nuser.should.be.an.instanceof(User);\r\n[].should.be.an.instanceOf(Array);\r\n```\r\n\r\n## .arguments\r\n\r\nAssert a given object is an `Arguments`:\r\n\r\n```javascript\r\nvar args = (function(){ return arguments; })(1,2,3);\r\nargs.should.be.arguments;\r\n[].should.not.be.arguments;\r\n```\r\n\r\n## .Object, .Number, .Array, .Boolean, .Function, .String, .Error\r\n\r\nAssert a given object is instance of the given constructor (shortcut for `.instanceof` assertion).\r\n\r\n```javascript\r\n({}).should.be.an.Object;\r\n(1).should.be.a.Number;\r\n[].should.be.an.Array.and.an.Object;\r\n(true).should.be.a.Boolean;\r\n''.should.be.a.String;\r\n```\r\n## .enumerable(name[, value])\r\n\r\nAssert a property exists, is enumerable, and has an optional value (compare using `.eql`):\r\n```javascript\r\n'asd'.should.not.have.enumerable('0');\r\nuser.should.have.enumerable('name');\r\nuser.should.have.enumerable('age', 15);\r\nuser.should.not.have.enumerable('rawr');\r\nuser.should.not.have.enumerable('age', 0);\r\n[1, 2].should.have.enumerable('0', 1);\r\n```\r\n\r\n## .property(name[, value])\r\n\r\nAssert property exists and has an optional value (compare using `.eql`):\r\n```javascript\r\nuser.should.have.property('name');\r\nuser.should.have.property('age', 15);\r\nuser.should.not.have.property('rawr');\r\nuser.should.not.have.property('age', 0);\r\n[1, 2].should.have.property('0', 1);\r\n```\r\n\r\n__NB__ `.property` changes the chain's object to the given property's value, so be careful when chaining after  `.property`!\r\n\r\n## .properties(propName1, propName2, ...) or .properties([propName1, propName2, ...]) or .properties(obj)\r\n\r\n`obj` should be an object that maps properties to their actual values.\r\n\r\nAssert all given properties exist and have given values (compare using `.eql`):\r\n\r\n```javascript\r\nuser.should.have.properties('name', 'age');\r\nuser.should.have.properties(['name', 'age']);\r\nuser.should.have.properties({\r\n    name: 'denis',\r\n    age: 24\r\n});\r\n```\r\n\r\n## .length(number) and .lengthOf(number)\r\n\r\nAssert _length_ property exists and has a value of the given number (shortcut for `.property('length', number)`):\r\n```javascript\r\nuser.pets.should.have.length(5);\r\nuser.pets.should.have.a.lengthOf(5);\r\n({ length: 10}).should.have.length(10);\r\n```\r\n\r\n__NB__ `.length` and `.lengthOf` change the chain's object to the given length value, so be careful when chaining!\r\n\r\n## .ownProperty(str) and .hasOwnProperty(str)\r\n\r\nAssert given object has own property (using `.hasOwnProperty`):\r\n```javascript\r\n({ foo: 'bar' }).should.have.ownProperty('foo').equal('bar');\r\n```\r\n\r\n__NB__ `.ownProperty` and `.hasOwnProperty` change the chain's object to the given property value, so be careful when chaining!\r\n\r\n## .empty\r\n\r\nAssert given value is empty. Strings, arrays, arguments with a length of 0, and objects without their own properties, are considered empty.\r\n\r\n```javascript\r\n[].should.be.empty;\r\n''.should.be.empty;\r\n({}).should.be.empty;\r\n(function() {\r\n  arguments.should.be.empty;\r\n})();\r\n```\r\n\r\n## .keys([key1, key2, ...]) and .keys(key1, key2, ...) and .key(key)\r\n\r\nAssert own object keys, which must match _exactly_,\r\nand will fail if you omit a key or two:\r\n\r\n```javascript\r\nvar obj = { foo: 'bar', baz: 'raz' };\r\nobj.should.have.keys('foo', 'baz');\r\nobj.should.have.keys(['foo', 'baz']);\r\n({}).should.have.keys();\r\n({}).should.have.keys('key'); //fail AssertionError: expected {} to have key 'key'missing keys: 'key'\r\n```\r\n\r\n## .propertyByPath([name1, ...]) or .propertyByPath(name1, name2, ...)\r\n\r\nAssert property exists and has optional value (compare using `.eql`):\r\n```javascript\r\nvar obj = { foo: 'bar', baz: 'raz', zad: { a: 10 } };\r\nobj.should.have.propertyByPath('zad', 'a');\r\nobj.should.not.have.propertyByPath(0, 1, 2);\r\n```\r\n\r\n__NB__ `.propertyByPath` changes the chain's object to the given property's value if found\r\n\r\n## .containEql(otherValue)\r\n\r\nAssert given value to contain something *.eql* to otherValue. See examples to understand better:\r\n\r\n```javascript\r\n'hello boy'.should.containEql('boy');\r\n[1,2,3].should.containEql(3);\r\n[[1],[2],[3]].should.containEql([3]);\r\n[[1],[2],[3, 4]].should.not.containEql([3]);\r\n\r\n({ b: 10 }).should.containEql({ b: 10 });\r\n([1, 2, { a: 10 }]).should.containEql({ a: 10 });\r\n[1, 2, 3].should.not.containEql({ a: 1 });\r\n\r\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containEql({a: 'a'});\r\n[{a: 'a'}, {b: 'b', c: 'c'}].should.not.containEql({b: 'b'});\r\n```\r\n\r\nWhen `.containEql` check arrays it check elements to be in the same order in `otherValue` and object just to be presented.\r\n\r\n## .containDeep(otherValue)\r\n\r\nAssert given value to contain something *.eql* to otherValue within depth.\r\nAgain see examples:\r\n\r\n```javascript\r\n'hello boy'.should.containDeep('boy');\r\n[1,2,3].should.containDeep([3]);\r\n[1,2,3].should.containDeep([1, 3]);\r\n//but not\r\n[1,2,3].should.containDeep([3, 1]);\r\n\r\n({ a: { b: 10 }, b: { c: 10, d: 11, a: { b: 10, c: 11} }}).should\r\n  .containDeep({ a: { b: 10 }, b: { c: 10, a: { c: 11 }}});\r\n\r\n[1, 2, 3, { a: { b: { d: 12 }}}].should.containDeep([{ a: { b: {d: 12}}}]);\r\n\r\n[[1],[2],[3]].should.containDeep([[3]]);\r\n[[1],[2],[3, 4]].should.containDeep([[3]]);\r\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{a: 'a'}]);\r\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{b: 'b'}]);\r\n```\r\n\r\nIt does not search somewhere in depth it check all pattern in depth. Objects are checked\r\nby properties key and value; arrays are checked like sub sequences. Everyting is compared using `.eql`.\r\nMain difference with `.containEql` is that this assertion requires full type chain -\r\nif asserted value is an object, otherValue should be also an object (which is sub object of given).\r\nThe same is true for arrays, otherValue should be an array which compared to be subsequence of given object.\r\n\r\nAlso exists assertion `.containDeepOrdered` which check arrays in the same order.\r\n\r\n## .match(otherValue)\r\n\r\nAssert given object matches `otherValue`.\r\n\r\nGiven: String, otherValue: regexp. Uses `RegExp#exec(str)`:\r\n```javascript\r\nusername.should.match(/^\\w+$/)\r\n```\r\n\r\nGiven: Array, otherValue: regexp - assert each value match to regexp.\r\n```javascript\r\n['a', 'b', 'c'].should.match(/[a-z]/);\r\n['a', 'b', 'c'].should.not.match(/[d-z]/);\r\n```\r\n\r\nGiven: Object, otherValue: regexp - assert own property's values to match regexp.\r\n```javascript\r\n({ a: 'foo', c: 'barfoo' }).should.match(/foo$/);\r\n({ a: 'a' }).should.not.match(/^http/);\r\n```\r\n\r\nGiven: Anything, otherValue: function - assert if given value matched to function.\r\n\r\nFunction can use `.should` inside or return 'true' or 'false', in all other cases it do nothing. If you return value that return assertion, you will receive better error messages.\r\n\r\n```javascript\r\n(5).should.match(function(n) { return n > 0; });\r\n(5).should.not.match(function(n) { return n < 0; });\r\n(5).should.not.match(function(it) { it.should.be.an.Array; });\r\n(5).should.match(function(it) { return it.should.be.a.Number; });\r\n```\r\n\r\nNow compare messages:\r\n```javascript\r\n(5).should.not.match(function(it) { it.should.be.a.Number; });\r\n//AssertionError: expected 5 not to match [Function]\r\n(5).should.not.match(function(it) { return it.should.be.a.Number; });\r\n//AssertionError: expected 5 not to match [Function]\r\n//\texpected 5 to be a number\r\n```\r\n\r\nGiven: object, otherValue: another object - assert that object properties match to properties of another object in meaning that describe above cases. See examples:\r\n\r\n```javascript\r\n({ a: 10, b: 'abc', c: { d: 10 }, d: 0 }).should\r\n    .match({ a: 10, b: /c$/, c: function(it) { return it.should.have.property('d', 10); }});\r\n\r\n[10, 'abc', { d: 10 }, 0].should\r\n\t.match({ '0': 10, '1': /c$/, '2': function(it) { return it.should.have.property('d', 10); } });\r\n\r\n[10, 'abc', { d: 10 }, 0].should\r\n    .match([10, /c$/, function(it) { return it.should.have.property('d', 10); }]);\r\n```\r\n\r\n## .matchEach(otherValue)\r\n\r\nAssert given property keys and values each match given check object.\r\n\r\nIf `otherValue` is RegExp, then each property value checked to match it:\r\n```javascript\r\n(['a', 'b', 'c']).should.matchEach(/[a-c]/);\r\n```\r\n\r\nIf `otherValue` is Function, then check each property value and key matched it:\r\n```javascript\r\n[10, 11, 12].should.matchEach(function(it) { return it >= 10; });\r\n[10, 11, 12].should.matchEach(function(it) { return it >= 10; });\r\n```\r\n\r\nIn other cases it checks that each property value is `.eql` to `otherValue`:\r\n```javascript\r\n[10, 10].should.matchEach(10);\r\n```\r\n## .throw() and throwError()\r\n\r\nAssert an exception is thrown:\r\n\r\n```js\r\n(function(){\r\n  throw new Error('fail');\r\n}).should.throw();\r\n```\r\n\r\nAssert an exception is not thrown:\r\n\r\n```js\r\n(function(){\r\n\r\n}).should.not.throw();\r\n```\r\nAssert exception message matches string:\r\n\r\n```js\r\n(function(){\r\n  throw new Error('fail');\r\n}).should.throw('fail');\r\n```\r\n\r\nAssert error message matches regexp:\r\n\r\n```js\r\n(function(){\r\n  throw new Error('failed to foo');\r\n}).should.throw(/^fail/);\r\n```\r\n\r\nError properties to match some other properties (used `.match`):\r\n\r\n```js\r\nvar error = new Error();\r\nerror.a = 10;\r\n(function(){ throw error; }).should.throw({ a: 10 });\r\n\r\n(function(){ throw error; }).should.throw(Error, { a: 10 });\r\n```\r\n\r\nIf you need to pass arguments and/or context to execute function use `Function#bind(context, arg1, ...)`:\r\n```js\r\nfunction isPositive(n) {\r\n    if(n <= 0) throw new Error('Given number is not positive')\r\n}\r\n\r\nisPositive.bind(null, 10).should.not.throw();\r\nisPositive.bind(null, -10).should.throw();\r\n```\r\n\r\nIf you need to check something in an asynchronous function, you must do it in 2 steps:\r\n\r\n```js\r\n// first we need to check that function is called\r\nvar called = false;\r\ncollection.findOne({ _id: 10 }, function(err, res) {\r\n    called = true;\r\n\r\n    //second we test what you want\r\n    res.should.be....\r\n});\r\n\r\ncalled.should.be.true;\r\n```\r\n\r\nIn case you are using something like `Mocha`, you should use an asynchronous test, and call `done()` in the proper place to make sure that your asynchronous function is called before the test finishes.\r\n```js\r\ncollection.findOne({ _id: 10 }, function(err, res) {\r\n    if(err) return done(err);\r\n    //second we test what you want\r\n    res.should.be....\r\n\r\n    done();\r\n});\r\n```\r\n\r\nIn general, if you need to check that something is executed, you are best using `spies`. A good example is [sinon](http://sinonjs.org/).\r\n\r\n## Optional Error description\r\n\r\nAs it can often be difficult to ascertain exactly where failed assertions are coming from in your tests, an optional description parameter can be passed to several should matchers. The description will follow the failed assertion in the error:\r\n\r\n    (1).should.eql(0, 'some useful description')\r\n\r\n    AssertionError: some useful description\r\n      at Object.eql (/Users/swift/code/should.js/node_modules/should/lib/should.js:280:10)\r\n      ...\r\n\r\nThe methods that support this optional description are: `eql`, `equal`, `within`, `instanceof`, `above`, `below`, `match`, `length`, `ownProperty`.\r\n\r\n## Mocha example\r\n\r\nFor example you can use should with the [Mocha test framework](http://visionmedia.github.io/mocha/) by simply including it:\r\n\r\n```javascript\r\nvar should = require('should');\r\nvar mylib = require('mylib');\r\n\r\n\r\ndescribe('mylib', function() {\r\n  it('should have a version with the format #.#.#', function() {\r\n    lib.version.should.match(/^\\d+\\.\\d+\\.\\d+$/);\r\n  });\r\n});\r\n```\r\n\r\n## Adding own assertions\r\n\r\nTo add own assertion you need to call `should.Assertion.add` function. It accept 3 arguments:\r\n\r\n1. name of assertion method (string)\r\n2. assertion function (function)\r\n3. optional boolean value to mark if this assertion should be getter\r\n\r\nWhat assertion function should do. It should check only positive case. `should` will handle `.not` itself.\r\n`this` in assertion function will be instance of `should.Assertion` and you **must** define in any way this.params object\r\n in your assertion function call before assertion check happen.\r\n\r\n`params` object can contain several fields:\r\n\r\n- `operator` - it is string which describe your assertion\r\n- `obj` it is string representation of this.obj if you need to define you own\r\n- `expected` it is any value that expected to be matched this.obj\r\n\r\nYou can assume its usage in generating AssertionError message like: expected `obj`? || this.obj not? `operator` `expected`?\r\n\r\nIn `should` sources appeared 2 kinds of usage of this method.\r\n\r\nFirst not preferred and used **only** for shortcuts to other assertions, e.g how `.should.be.true` defined:\r\n\r\n```javascript\r\nAssertion.add('true', function() {\r\n    this.is.exactly(true);\r\n}, true);\r\n```\r\nThere you can see that assertion function do not define own `this.params` and instead call within the same assertion `.exactly`\r\nthat will fill `this.params`. **You should use this way very carefully, but you can use it**.\r\n\r\nSecond way preferred and i assume you will use it instead of first.\r\n\r\n```javascript\r\nAssertion.add('true', function() {\r\n    this.params = { operator: 'to be true', expected: true };\r\n\r\n    this.obj.should.be.exactly(true);\r\n}, true);\r\n```\r\nin this case this.params defined and then used new assertion context (because called `.should`). Internally this way does not\r\n create any edge cases as first.\r\n\r\n```javascript\r\nAssertion.add('asset', function() {\r\n    this.params = { operator: 'to be asset' };\r\n\r\n    this.obj.should.have.property('id').which.is.a.Number;\r\n    this.obj.should.have.property('path');\r\n})\r\n\r\n//then\r\n> ({ id: '10' }).should.be.an.asset();\r\nAssertionError: expected { id: '10' } to be asset\r\n    expected '10' to be a number\r\n\r\n> ({ id: 10 }).should.be.an.asset();\r\nAssertionError: expected { id: 10 } to be asset\r\n    expected { id: 10 } to have property path\r\n```\r\n\r\n\r\n## Contributions\r\n\r\n[Actual list of contributors](https://github.com/visionmedia/should.js/graphs/contributors) if you want to show it your friends.\r\n\r\nTo run the tests for _should_ simply run:\r\n\r\n    $ make test\r\n\r\nSee also [CONTRIBUTING](./CONTRIBUTING.md).\r\n\r\n## OMG IT EXTENDS OBJECT???!?!@\r\n\r\nYes, yes it does, with a single getter _should_, and no it won't break your code, because it does this **properly** with a non-enumerable property.\r\n\r\n## License\r\n\r\nMIT &copy; 2010-2014 TJ Holowaychuk\r\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/shouldjs/should.js/issues"
  },
  "_id": "should@4.1.0",
  "dist": {
    "shasum": "d1907221e9b3c52be64e4d3ab03360dc4d080140"
  },
  "_from": "should@",
  "_resolved": "https://registry.npmjs.org/should/-/should-4.1.0.tgz"
}
